   # CHAPTER 3
# Topics Covered:

# Spawing_a_Process:
This code demonstrates **process spawning** using Python's `multiprocessing` module, where each iteration creates a new process to execute `myFunc`. A process is an independent unit of execution with its own memory space. Here, `myFunc` prints a message and iterates from `0` to the given number `i`, printing values. The `main` function spawns and starts one process at a time with `process.start()`, and `process.join()` ensures the main program waits for the current process to finish before starting the next. This sequential execution limits parallelism, but it showcases how processes are created and managed for tasks.

# Communication_with_pipe:
This code demonstrates *inter-process communication* using **pipes** in Python's `multiprocessing` module. It creates two processes: `create_items`, which generates numbers from 0 to 9 and sends them through the first pipe (`pipe_1`), and `multiply_items`, which reads those numbers, squares them, and sends the results through the second pipe (`pipe_2`). The main process closes the unused ends of the pipes and continuously reads the squared numbers from `pipe_2`. When all data is processed, an `EOFError` indicates the end of data, and the loop exits with the message "End". The pipes serve as unidirectional communication channels, transferring data between the processes. Using `Pipe(True)` creates a duplex pipe, allowing both ends to send and receive data. This approach facilitates concurrent execution, where processes work independently while communicating efficiently via pipes to exchange data. The final output displays the squares of numbers from 0 to 9, followed by "End".

# Communication_with_queue:
This code demonstrates *inter-process communication* using a shared **queue** in Python's `multiprocessing` module, implementing the producer-consumer model. The **producer** generates 10 random integers and appends them to the shared queue, while the **consumer** retrieves and processes these items. The queue ensures thread-safe communication between the processes. The producer and consumer run independently, with the producer adding data and the consumer consuming it. The queue synchronizes access, preventing race conditions. The output shows the producer appending items and the consumer processing them, illustrating a concurrent workflow.

# Daemon:
This code demonstrates the use of **daemon** and **non-daemon processes** in Python's `multiprocessing` module. Two processes are created: a **background (daemon) process** and a **non-background (non-daemon) process**. The `foo` function, executed by both processes, prints a sequence of numbers depending on the process type. The background process runs as a daemon, meaning it can be terminated when the main program ends, even if it hasn't completed its task. The non-background process runs to completion, as it is non-daemon. The main program allows the daemon process to run briefly by adding a `time.sleep(2)` delay. The output shows both processes printing their sequences, with the daemon process potentially being interrupted if the main program ends too soon.

# Killing_processes:
This code demonstrates creating and controlling a process using Python's `multiprocessing` module. The `foo()` function prints numbers from 0 to 9 with a 1-second delay between each, but the process is terminated before completing its task. The program first checks the process status before starting, then starts the process, checks if itâ€™s running, and immediately terminates it. After termination, the process is joined, ensuring the main program waits for it. The exit code is `-9`, indicating the process was forcibly terminated.

# myFunct:
This code creates and runs 6 processes using Python's `multiprocessing` module. The `myFunc()` function prints a message indicating the process number and then prints output based on the loop from 0 to `i`. In the `main()` function, a new process is created for each iteration with `myFunc()` as the target, passing `i` as an argument. The `start()` method begins the process, and `join()` ensures that each process completes before starting the next one. This results in sequential execution of the processes, with each one printing its output.

# Naming_processes:
This code demonstrates creating two processes using Python's `multiprocessing` module. The `myFunc()` function is executed by both processes, printing the process name before and after sleeping for 3 seconds. One process is assigned a custom name (`'myFunc process'`), while the other uses the default name generated by the system. Both processes are started with `start()` and synchronized using `join()`, ensuring the main program waits for them to complete before continuing. The output shows the starting and exiting messages for both processes, each identified by its name.

# Process_Barrier:
This code demonstrates the use of synchronization and serialization in Python's `multiprocessing` module. It creates two types of processes: processes with a barrier and processes without a barrier. The `test_with_barrier()` function uses a `Barrier` to synchronize two processes, ensuring they wait for each other before printing the current timestamp. The `test_without_barrier()` function does not use any synchronization and prints the timestamp immediately. Additionally, a `Lock` is used in `test_with_barrier()` to serialize access to the print statement. Four processes are created, two of which use the barrier and two do not, demonstrating different synchronization behaviors.

# Process_in_subclass:
This code demonstrates creating custom processes in Python using the `multiprocessing` module. A subclass of `multiprocessing.Process` is defined as `MyProcess`, where the `run()` method is overridden to print a message indicating the process's name. In the `main()` block, a loop creates 10 instances of `MyProcess`, each of which is started with the `start()` method and then waited for to complete using `join()`. This ensures that each process runs sequentially, with the program waiting for each one to finish before starting the next.

# Process_pool:
This code demonstrates using a process pool in Python's `multiprocessing` module to perform parallel computation. The `function_square()` function squares each input number. In the `main()` block, a pool of 4 processes is created using `multiprocessing.Pool`, and the `pool.map()` method is used to apply `function_square` to a list of numbers from 0 to 99. After the computation, `pool.close()` ensures no new tasks can be added, and `pool.join()` waits for all processes to finish. Finally, the results (squared numbers) are printed. This approach enables concurrent execution, improving performance for large tasks.

# run_background_process:
This code demonstrates the use of background and non-background processes in Python's `multiprocessing` module. The `foo()` function prints a message indicating the process's name, then executes a loop based on the process name. The `background_process` is a daemon process, meaning it will automatically exit when the main program finishes, without waiting for it to complete. It prints numbers 0 to 4 and then sleeps for 1 second. The `NO_background_process` is a non-daemon process, meaning the program will wait for it to finish before exiting. It prints numbers 5 to 9, then sleeps for 1 second. The `start()` method begins both processes concurrently, and the program ensures that each process performs its designated tasks based on the name assigned to it.

# run_background_processes_no_deamon:
This code demonstrates the creation of two processes using Python's `multiprocessing` module, with both processes running concurrently. The `foo()` function prints the process name, and based on that name, it performs different tasks. If the process is named `'background_process'`, it prints numbers from 0 to 4 and then sleeps for 1 second. Otherwise, the `'NO_background_process'` prints numbers from 5 to 9 and also sleeps for 1 second. Both processes are set to `daemon=False`, meaning the main program will wait for them to finish before exiting. The processes are started using the `start()` method, and they run concurrently, with each printing its respective numbers and performing a sleep operation. Since both processes are non-daemon, the program will wait for both to finish before exiting.

# Spawing_namespaces:
This code demonstrates the use of the `multiprocessing` module in Python to create and execute multiple processes. The `myFunc` function is imported from another module and is executed by each process. Inside the `if __name__ == '__main__'` block, a loop runs six times, and for each iteration, a new process is created with the target function `myFunc` and an argument `i` (which varies from 0 to 5). The `start()` method begins each process, and the `join()` method ensures that the program waits for the process to finish before starting the next one. This way, each process runs sequentially, one after the other, and after the loop completes, the program terminates. This approach allows for parallel execution of tasks using multiple processes, but with each process waiting for the previous one to finish.
